#!/usr/bin/perl
#
# import - imports BIND configuration/databases
#
# Copyright (c) Timo Kokkonen <tjko@iki.fi>  2000.
# $Id$
#
require 5;
use Net::Netmask;

($PG_DIR,$PG_NAME) = ($0 =~ /^(.*\/)(.*)$/);
$0 = $PG_NAME;

do "$PG_DIR/config" || die("cannot load config");
do "$PG_DIR/util.pl";
do "$PG_DIR/util_zone.pl";
do "$PG_DIR/db.pl";

# if these are not defined, then values are taken from first master zone
# processed...
# $hostmaster = 'hostmaster.cc.jyu.fi.';
# $primaryservername = 'tukki.cc.jyu.fi.';

##############################


if (@ARGV != 2) {
    print "syntax: $0 <servername> <named.conf file>\n";
    exit(1);
}

$servername = $ARGV[0];
$namedf = $ARGV[1];
$user = (getpwuid($<))[0];
%zonedata = {};

db_connect();

#$serverid=1;
#goto 'foo';

die("cannot open named.conf ($namedf)") if (! -f $namedf);

if ($namedf =~ /(^.*\/)/) { 
    $dir=$1; 
} else { 
    $dir="./"; 
}

print "servername: $servername\n";
print "dir: $dir\n";

db_debug(1);

############################################
# parse named.conf

open(NAMEDCONF,"$PROG_DIR/parseconf.pl $namedf |") 
        || die("cannot open named.conf ($namedf)");


while (<NAMEDCONF>) {
    # eat comments (just in case... parseconf.pl should produce clean output)
    if ( /(^.*?)(\/\/.*$)/ ) { $_=$1; }
    if ( /(^.*?)(#.*$)/ ) { $_=$1; }

    if ( /^\s*([A-Za-z\-\_]+)\s*{(.*$)/ ) {
	#print "begin '$1'\n";
	push @block,$1;
	next;
    }

    if ( /^\s*zone\s+\"(.*?)\"(\s+(in|hs|hesiod|chaos))?\s*{/ ) {
	#print "begin 'zone $1'\n";
	push @block, "zone $1";
	push @zones, $1;
	$ref = [];
	$masters{$1} = $ref;
	next;
    }			      

    s/\s+/\ /g;
    next if /^\s*$/;
	 
    if ( /(^.*?)};/ ) {
	#print "end '$block[$#block]'\n";
	pop @block;
	next;
    }			       
	 

   $cur = $block[$#block];
   $prev = "";
   $prev = $block[$#block -1] if ($#block > 0);			       

   $line=$_;
   $line =~ s/(^\s+|;\s*$)//g;			
		       
   if ($cur =~ "options")  {
       if ( /directory\s+\"(.*?)\"\s*;/ ) {
	   $directory=$1; 
	   print "directory=$directory\n";
	   next;
       }
   }
   if ($prev =~ "options") {
       if ($cur =~ "allow-transfer" && ($ip=is_cidr($line)) ) {
	   #print "allow transfer ip=$ip\n";
	   push @allow_transfer, $ip;
	   next;
       }
   }

   if ($cur =~ /^zone (.*)$/) {
       $curzone = $1;
       if ( /type\s+(\S+)\s*;/ ) {
	   #print "type=$1\n";
	   $types{$curzone} = $1;
	   next;
       }
       if ( /file\s+"(\S+)"\s*;/ ) {
	   #print "file=$1\n";
	   $files{$curzone} = $1;
	   $named_ca = $1 if ($curzone eq '.');
	   next;
       }
       if ( /check\-names\s+(\S+)\s*;/ ) {
	   #print "check-names=$1\n";
	   $checknames{$curzone} = $1;
	   next;
       }
   }
   if ($prev =~ /^zone\s+(.*)$/) {
       $curzone=$1;
       if ($cur =~ "masters" && ($ip=is_cidr($line))) {
	   #print "master ($curzone) ip=$ip\n";
	   $ref = $masters{$curzone};
	   unless ($ref) {
	     $masters{$curzone}=[];
	     $ref = $masters{$curzone};
	   }
	   push @{$ref}, $ip;
	   next;
       }
       if ($cur =~ "allow-update" && ($ip=is_cidr($line))) {
	   #print "allow-update ($curzone) ip=$ip\n";
	   $ref = $allowupdate{$curzone};
	   unless ($ref) {
	     $allowupdate{$curzone}=[];
	     $ref = $allowupdate{$curzone};
	   }
	   push @{$ref}, $ip;
	   next;
       }
   }

    print "UNPROCESSED: $_\n";
}

close(NAMEDCONF);

$c = keys %masters;

print "Found $c zones (rootserverfile=$named_ca)\n";

die("no directory option in named.conf!") if ($directory eq '');
chdir($directory) || die ("cannot chdir to: $directory");

db_begin();

##################################
# create server record

$sqlstr = "INSERT INTO servers " .
      " (name,comment,named_ca,directory,cuser,muser) " .
      "VALUES ('$servername','imported from named.conf',".
      "'$named_ca','$directory','$user','$user');";

die("Cannot create server record '$servername' (already exists?)")
	 if (db_exec($sqlstr) < 0);

$res = db_exec("SELECT id,name FROM servers WHERE name='$servername';");
die("unexpected error: Cannot get server record id!") if ($res != 1);

$serverid = db_getvalue(0,0);

print "id=$serverid\n";

# build & update allow_transfer field
for($i=0; $i <= $#allow_transfer; $i+=1) {
  if (($ip=is_cidr($allow_transfer[$i]))) {
    $arr.="," if ($arr);
    $arr.="\"$ip\"";

    die("cannot update allow_transfer table!") 
      if (db_exec("INSERT INTO cidr_entries " .
		  "(type,ref,ip) VALUES(1,$serverid,'$ip');"));
  }
}

$serverid_save = $serverid;


#########################################
# create zones

$loopback = new Net::Netmask($LOOPBACK_NET);
$loopback_reverse=($loopback->inaddr())[0];

# make sure in-adrr.arpa zones are processed last
for($i=0; $i <= $#zones; $i+=1) {
  push @zones2, $zones[$i] unless ($zones[$i] =~ /\.in-addr\.arpa/);
}
for($i=0; $i <= $#zones; $i+=1) {
  push @zones2, $zones[$i] if ($zones[$i] =~ /\.in-addr\.arpa/);
}
@zones=@zones2;


########################
# process zones
for ($i=0; $i <= $#zones; $i+=1) {
  $zone=$zones[$i];
  next if ($zone eq '.');
  $zone =~ s/\.$//g;
  if ($zone =~ /\.$/) { $origin=$zone; } else { $origin = $zone . '.'; }
  $rev='false';
  $rev='true' if ($zone =~ /\.in-addr\.arpa/);

  print "zone: '" . $zone . "' ";

  if ($zone =~ /$LOOPBACK_ZONE|$loopback_reverse/) {
    $loopback = 'true';
    #$serverid = 0;
    print "loopback ";
  } else {
    $loopback = 'false';
    #$serverid = $serverid_save;
  }


  $type='M';
  $type='S' if ($types{$zones[$i]} eq 'slave');
  $check_names=$checknames{$zones[$i]};
  if ($check_names =~ /ignore/) { $check_names='I'; }
  elsif ($check_names =~ /fail/) { $check_names='F'; }
  else { $check_names='W'; };


  $sqlstr="INSERT INTO zones " .
    "(cuser,muser,server,type,reverse,name,chknames) " .
      "VALUES" .
	"('$user','$user',$serverid,'$type',$rev,'$zone','$check_names');";
  $res=db_exec($sqlstr);
  if ($res < 0) {
    print "zone allready exists! skipping\n";
    next;
  }
  #die("cannot create zone record '$zone'") if ($res < 0);

  $res=db_exec("SELECT id FROM zones WHERE " .
	       "name='$zone' AND server=$serverid;");
  die("unexpected error: Cannot get zone record id!") if ($res != 1);
  $zoneid = db_getvalue(0,0);
  print " (id=$zoneid)";

  # allow_update IPs...
  foreach $ip (@{$allowupdate{$zones[$i]}}) {
    $sqlstr="INSERT INTO cidr_entries (type,ref,ip) ".
      "VALUES(2,$zoneid,'$ip');";
    die("cannot insert allow-update IPs id=$zoneid!") if (db_exec($sqlstr)<0);
  }


  push(@loopbacks_list,$zoneid) if ($loopback eq 'true');

  # handle slave zones
  unless ($type eq 'M') {
    print "slave zone\n";
    foreach $ip (@{$masters{$zones[$i]}}) {
      $sqlstr="INSERT INTO cidr_entries (type,ref,ip) ".
              "VALUES(3,$zoneid,'$ip');";
      die("cannot insert master IPs id=$zoneid!") if (db_exec($sqlstr)<0);
    }

    next;
  }

  print "\n";


  #handle master zones
  undef %zonedata;
  if (! -f $files{$zones[$i]} ) { # check for dummy zones (such as AD zones :)
    print "cannot find: '$files{$zones[$i]}' marking as dummy zone!!!\n"; 
    $sqlstr="UPDATE zones SET dummy=true WHERE id=$zoneid;";
    die("cannot update zone record id=$zoneid!") if (db_exec($sqlstr)<0);
    next;
  }
  process_zonefile("fh0000",$files{$zones[$i]},$zone,\%zonedata);
  print " found " . keys(%zonedata) . " domainames in zone\n";
  $rec = $zonedata{$origin};
  die ("No SOA record found in zone $zone! ($origin)") if (! $rec);
  
  $ttl=$rec->{TTL};
  $class=$rec->{CLASS};
  @soa = split ' ',$rec->{SOA};
  $mailbox = $soa[1];
  $hostmaster = $mailbox if (! $hostmaster );
  $primaryservername = $soa[0] if ( ! $primaryservername );

  foreach $rtmp (@{$rec->{NS}}) {
    $sqlstr="INSERT INTO ns_entries (type,ref,ns) ".
      "VALUES(1,$zoneid,'$rtmp');";
    die("cannot insert NS entries id=$zoneid!") if (db_exec($sqlstr)<0);
  }
  if ($rev eq 'true') {
    # do nothing
  } else {
    foreach $rtmp (@{$rec->{MX}}) {
      next unless $rtmp =~ /^\s*(\d+)\s+(\S+)\s*$/;
      $sqlstr="INSERT INTO mx_entries (type,ref,pri,mx) ".
	"VALUES(1,$zoneid,$1,'$2');";
      die("cannot insert MX entries id=$zoneid!") if (db_exec($sqlstr)<0);
    }

    foreach $rtmp (@{$rec->{TXT}}) {
      $sqlstr="INSERT INTO txt_entries (type,ref,txt) ".
	"VALUES(1,$zoneid,'$rtmp');";
      die("cannot insert TXT entries id=$zoneid!") if (db_exec($sqlstr)<0);
    }
  }
  if ($mailbox eq $hostmaster) {
    $mailbox='NULL';
  } else {
    $mailbox="'$mailbox'";
  }

  $sqlstr = "UPDATE zones SET " .
            "class='$class', ttl=$ttl, hostmaster=$mailbox," .
	    "serial=$soa[2], refresh=$soa[3], retry=$soa[4], expire=$soa[5]," .
	    "minimum=$soa[6] " .
	    " WHERE id=$zoneid;";

  $res = db_exec($sqlstr);
  die("Cannot update zone record '$zone'") if ($res < 0);

  delete $zonedata{$origin} if (@{$rec->{A}} < 1);



  if ($rev eq 'true') {
    #handle reverse zone

    # add subnet delegations
    #db_begin();
    foreach $host (keys %zonedata) {
      $rec = $zonedata{$host};
      next if ($rec->{CNAME} eq '' && @{$rec->{NS}}<1);

      $host2=remove_origin($host,$origin);
      $cname="'$rec->{CNAME}'";
      $cname='NULL' if ($cname eq '');
      $hosttype=0;
      $hosttype=2 unless ($nslist eq '');

      $sqlstr = "INSERT INTO hosts " .
	"(cuser,muser,zone,type,domain,class,cname_txt) " .
	"VALUES(" .
	"'$user','$user',$zoneid,$hosttype,'$host2','$class',$cname);";

      $res = db_exec($sqlstr);
      die("cannot insert (reverse) host record '$host'") if ($res < 0);

      $res = db_exec("SELECT id FROM hosts WHERE zone=$zoneid " .
		     "AND domain='$host2';");
      die("unexpected error: cannot get host record id!") if ($res != 1);
      $tmpid=db_getvalue(0,0);
      
      foreach $rtmp (@{$rec->{NS}}) {
	$sqlstr="INSERT INTO ns_entries (type,ref,ns) ".
	  "VALUES(2,$tmpid,'$rtmp');";
	die("cannot insert NS record id=$tmpid!") if (db_exec($sqlstr)<0);
      }
      
      print STDERR "@";
    }
    #die("Cannot commit (reverse) host record inserts!") if (db_commit()<0);


    # figure out what name to use in reverse lookups of IPs with multiple
    # domainnames

    if (! $mips_searched) { # search for IPs with multiple names only once
      #db_vacuum();
      $mips_searched=1;
      find_multi_ips($serverid);
    }

    print "\nFigure out reverses for IPs with multiple domainnames...\n";
    $net = new Net::Netmask(arpa2cidr($origin));
    foreach $ip (keys %mips) {
      if ($net->match($ip)) {
	$rip=cidr2arpa($ip) .".";
	#print "ip=$ip rev=$rip\n";
	delete $mips{$ip};
	$rec=$zonedata{$rip};
	if ($rec) {
	  print "$ip:$rip --> $rec->{PTR}\n";
	  $sqlstr = "SELECT rr_a.id, hosts.domain, zones.name " .
#	          "hosts.domain || '.' || zones.name || '.' AS dname " .
		  "FROM rr_a,hosts,zones,servers " .
	          "WHERE rr_a.host=hosts.id AND hosts.zone=zones.id " .
		  "AND zones.server=servers.id AND servers.id=$serverid AND " .
#		  "AND zones.server=servers.id AND " .
		   "ip='$ip';";  
	  $res=db_exec($sqlstr);
	  die("unexpected error: not A records found for $ip!") if ($res < 1);
	  undef %rhash;
	  for($j=0;$j<$res;$j++) {
	    $rid = db_getvalue($j,0);
	    $rhost = db_getvalue($j,1);
	    if ($rhost eq '@') { 
	      $rhost= db_getvalue($j,2) . '.'; 
	    } 
	    else { 
	      $rhost .= '.' . db_getvalue($j,2) . "." unless ($rhost =~ /\.$/);
	    }

	    $rhash{$rhost}=$rid;
	  }

	  #db_begin();
	  foreach $rhost (keys %rhash) {
	    $rid=$rhash{$rhost};
	    $rflag = 'false';
	    $rflag = 'true' if ($rec->{PTR} eq $rhost);
	    #print "$rid : $rhost : $rflag\n";
	    $sqlstr = "UPDATE rr_a SET reverse=$rflag WHERE id=$rid;";
	    $res=db_exec($sqlstr);
	    die("cannot update rr_a record id=$rid host=$rhost") if ($res < 0);
	    warn("fail: $sqlstr") if (db_status() ne 'UPDATE 1');
	  }
	  #die("cannot commit rr_a record updates!") if (db_commit() < 0);
	}
	else {
	  warn("cannot find $rip in zone $zone!");
	}
      }
    }


    $reversenet=arpa2cidr($zone);
    $sqlstr = "UPDATE zones SET reversenet='$reversenet' WHERE id=$zoneid;";
    $res = db_exec($sqlstr);
    die("cannot update zone record (id=$zoneid)!") if ($res < 0);

    next;
  }

  

  # hande normal zone

  undef @gluelist;
  undef %mxhash;
  undef %wkshash;

  # first build MX and WKS entry tables....
  foreach $host (keys %zonedata) {
    $rec=$zonedata{$host};
    $mxlist = db_build_list_str($rec->{MX});
    $wkslist = db_build_list_str($rec->{WKS});
    $mxhash{$mxlist}+=1 if (length($mxlist) > 0);
    $wkshash{$wkslist}+=1 if (length($wkslist) > 0);
  }

  #db_begin();
  foreach $wks (keys %wkshash) {
    $c=$wkshash{$wks};
    #print "wks: '$wks' $c\n";
    $wks_i_count++;
    $sqlstr="INSERT INTO rr_wks (server,comment) " .
            "VALUES($serverid," .
            "'$servername:$wks_i_count');";
    $res=db_exec($sqlstr);
    die("cannot insert record in rr_wks") if ($res < 0);
    $oid=db_lastoid();
    $sqlstr="SELECT id FROM rr_wks WHERE OID=$oid";
        #"AND server=$serverid AND wks='{$wks}';";
    $res=db_exec($sqlstr);
    die("cannot get record id from rr_wks!") if ($res < 0);
    $c=db_getvalue(0,0);
    $wkshash{$wks}=$c;
    #print "id=$c\n";

    $tmplist=db_decode_list_str("{$wks}");
    foreach $rtmp (@{$tmplist}) {
      next unless $rtmp =~ /^\s*(\S+)\s+(\S.*)$/;
      $sqlstr="INSERT INTO wks_entries (type,ref,proto,services) ".
	"VALUES(2,$c,'$1','$2');";
      die("cannot insert WKS entries id=$c!") if (db_exec($sqlstr)<0);
    }
  }
  #die("Cannot commit rr_wks inserts!") if (db_commit() < 0);

  #db_begin();
  foreach $mx (keys %mxhash) {
    $c=$mxhash{$mx};
    #print "mx: '$mx' $c\n";
    $mx_i_count++;
    $sqlstr="INSERT INTO rr_mx (zone,comment) VALUES($zoneid," .
            "'$zone:$mx_i_count');";
    $res=db_exec($sqlstr);
    die("cannot insert record in rr_mx") if ($res < 0);
    $oid=db_lastoid();
    $sqlstr="SELECT id FROM rr_mx WHERE OID=$oid;";
        #"AND zone=$zoneid AND mx='{$mx}';";
    $res=db_exec($sqlstr);
    die("cannot get record id from rr_mx!") if ($res < 0);
    $c=db_getvalue(0,0);
    $mxhash{$mx}=$c;
    #print "id=$c\n";

    $tmplist=db_decode_list_str("{$mx}");
    foreach $rtmp (@{$tmplist}) {
      next unless $rtmp =~ /^\s*(\d+)\s+(\S+)\s*$/;
      $sqlstr="INSERT INTO mx_entries (type,ref,pri,mx) ".
	"VALUES(3,$c,'$1','$2');";
      #print STDERR "MX insert:$sqlstr\n";
      die("cannot insert MX entries id=$c!") if (db_exec($sqlstr)<0);
    }
  }
  #die("Cannot commit rr_mx inserts!") if (db_commit() < 0);

  
  # insert records in hosts table....
  $c = keys %zonedata;
  print STDERR "Inserting $c records...";
  $j=0; $str='';
  #db_begin();
  
  foreach $host (keys %zonedata) {
    $rec = $zonedata{$host};
    next unless ($rec->{CNAME} eq '');


    #print "$host\n";
    $nslist = db_build_list_str($rec->{NS});
    $mxlist = db_build_list_str($rec->{MX});
    $wkslist = db_build_list_str($rec->{WKS});
    #$alist = db_build_list_str($rec->{A});
    #$a = "\'$rec->{A}[0]\'";
    $txtlist = db_build_list_str($rec->{TXT});
    $hinfo1=$rec->{HINFO}[0];
    $hinfo2=$rec->{HINFO}[1];
    $mx=$mxhash{$mxlist};
    $wks=$wkshash{$wkslist};
    $mx=-1 if (! $mx);
    $wks=-1 if (! $wks);
    $a = 'NULL' if ($a eq "''");
    $host2=remove_origin($host,$origin);
    if ($host2 eq $origin) {
      $host2='@';
      $nslist = '';
      $mx=-1;
    }

    $hosttype=0; # misc / unknown entry type
    $hosttype=1 if (@{$rec->{A}} > 0); # host
    $hosttype=2 if ($nslist ne '' && $host2 ne '@'); # delegated subdomains
    $hosttype=3 if ($nslist eq '' && @{$rec->{A}} < 1 && @{$rec->{MX}} > 0);
    
    if ($hosttype == 2) { 
      if ($host =~ /in-addr\.arpa/) {
	print STDERR "\nIGNORING reverse delegation $host in zone $zone \n",
                     " (reverse mapping stuff should be in in-arpa zone)\n";
	delete $zonedata{$host};
	next;
      }

      # check for NS entries requiring (possibly) glue records
      foreach $gns (@{$rec->{NS}}) {
	if ($gns =~ /^(\S*($host2))(\.$origin)$/) {
	  #print "ns: $gns 1=$1 2=$2 3=$3\n";
	  push @gluelist, $1;
	}
      }
    }

    if ($hosttype == 0) {
      print STDERR "\nIGNORING uknown host entry '$host' in zone $zone\n";
      delete $zonedata{$host};
      next;
    }

    die("empty hostname after stripping origin '$host'")  if ($host2 eq '');
    #print STDERR "$host: many IPs\n" if (@{$rec->{A}} > 1); 

    $sqlstr = "INSERT INTO hosts " .
        "(cuser,muser,zone,type,domain,class,mx,wks,hinfo_hw,hinfo_sw) " .
	"VALUES(" .
	"'$user','$user',$zoneid,$hosttype,'$host2','$class'," .
	"$mx,$wks,'$hinfo1','$hinfo2'" .
	");";
    #print RRFILE "$sqlstr\n";
    $j+=1;
    $str.=$sqlstr."\n";
    if ($j>50) {
      $res = db_exec($str);
      #sql_print_result($db_last_result);
      die("Cannot insert host record '$host'") if ($res < 0);
      $str='';
      $j=0; 
      print STDERR ".";
    }
  }
  unless ($str eq '') {
    print STDERR "|";
    $res = db_exec($str);
    die("Cannot insert host record '$host'") if ($res < 0);
  }
  #die("Cannot commit host record inserts!") if (db_commit() < 0);
  
  # fetch id's of records inserted earlier
  $sqlstr = "SELECT id,domain FROM hosts WHERE zone=$zoneid;";
  $res = db_exec($sqlstr);
  die("Cannot select previously inserted host records!") if ($res < 1);
  print STDERR "($res)";
  for($j=0;$j<$res;$j+=1) {
    $id=db_getvalue($j,0);
    $dom=add_origin(db_getvalue($j,1),$origin);
    if ($zonedata{$dom}) {
      $rec=$zonedata{$dom};
      $rec->{ID}=$id;
    } else {
      die("cannot find host '$dom' from hash! (unexpected error)");
    }
  }
  

  
  # insert alias (CNAME) records
  $j=0; $str='';
  #db_begin();
  
  foreach $host (keys %zonedata) {
    $rec = $zonedata{$host};
    next if ($rec->{CNAME} eq '');
    
    $rec2 = $zonedata{$rec->{CNAME}};
    if (! $rec2) {
      #warn("cannot find aliased host $host --> $rec->{CNAME}\n");
      $cname2="'$rec->{CNAME}'";
      $alias=-1;
    } else {
      $cname2="NULL";
      $alias=$rec2->{ID};
    }
    $host2=remove_origin($host,$origin);
    
    $sqlstr = "INSERT INTO hosts " .
      "(cuser,muser,zone,type,domain,class,alias,cname_txt,cname) ".
	"VALUES(" .
	"'$user','$user',$zoneid,4,'$host2','$class'," .
	"$alias,$cname2,true" .
	");";

    delete $zonedata{$host};

    $j+=1;
    $str.=$sqlstr . "\n";
    if ($j > 50) {
      $res = db_exec($str);
      die("Cannot insert alias host record '$host'") if ($res < 0);
      $j=0;
      $str='';
      print STDERR "+";
    }
  }
  unless ($str eq '') {
    print STDERR "|";
    $res = db_exec($str);
    die("Cannot insert alias host record '$host'") if ($res < 0);
  }
  #die("Cannot commit alias record inserts!") if (db_commit() < 0);

    
  # add A records in rr_a
  $j=0; $str='';
  #db_begin();

  foreach $host (keys %zonedata) {
    $rec = $zonedata{$host};
    $c = @{$rec->{A}};
    if ($c < 1) {
      warn("unexpected host without A records found '$host'")
	if (@{$rec->{NS}} < 1  &&  @{$rec->{MX}} < 1 && @{$rec->{SRV}} < 1);
      next;
    }
    $hostid=$rec->{ID};
    $reverse='true';
    if ($hostid < 1 || !$hostid) {
      warn("no id found in hash for host $host (adding A records)!") ;
      next;
    }
    
    for($k=0; $k < $c; $k+=1) {
      $ip=$rec->{A}[$k];
      $sqlstr = "INSERT INTO rr_a (host,ip,reverse) " .
	"VALUES($hostid,'$ip',$reverse);";
      
      $j++;
      $str.=$sqlstr . "\n";
      if ($j > 100) {
	$res = db_exec($str);
	die("cannot insert A record '$host'") if ($res < 0);
	$j=0;
	$str='';
	print STDERR "#";
      }
    }
    
  }
  unless ($str eq '') {
    $res = db_exec($str);
    die("cannot insert A record '$host'") if ($res < 0);
    print STDERR "|";
  }
  #die("Cannot commit A record inserts!") if (db_commit() < 0);


  # add MX & WKS template pointers to host entries
  #db_begin();
  $j=0;
  foreach $host (keys %zonedata) {
    $rec = $zonedata{$host};

    $mx=$mxhash{db_build_list_str($rec->{MX})};
    $wks=$wkshash{db_build_list_str($rec->{WKS})};
    $mx=-1 if (! $mx);
    $wks=-1 if (! $wks);
    $tmpid=$rec->{ID};

    if ($mx > 0  || $wks > 1) {
      die("no id found in hash for host $host (MX/WKS ptr update)!") 
	if ($tmpid < 1 || !$tmpid);
      if ($j>100) {
	print STDERR "ö";
	$j=0;
      }
      die("invalid id for record '$host'!") if ($tmpid < 1);
      $res=db_exec("UPDATE hosts SET mx=$mx,wks=$wks WHERE id=$tmpid;");
      $j++;
    }
  }  
  #die("Cannot commit MX & WKS tempate pointer updates!") if (db_commit() < 0);


  # add NS & TXT entries to ns_entries & txt_entries tables accordingly
  #db_begin();
  $j=0;
  foreach $host (keys %zonedata) {
    $rec = $zonedata{$host};

    $mx=$mxhash{db_build_list_str($rec->{MX})};
    $wks=$wkshash{db_build_list_str($rec->{WKS})};
    $mx=-1 if (! $mx);
    $wks=-1 if (! $wks);
    $tmpid=$rec->{ID};
    if ($tmpid < 1 || !$tmpid) {
      warn("no id found in hash for host $host (NS/TXT)!") ;
      next;
    }

    if (@{$rec->{NS}} > 0) {
      $sqlstr='';
      foreach $rtmp (@{$rec->{NS}}) {
	$sqlstr .= "INSERT INTO ns_entries (type,ref,ns) " . 
                   " VALUES(2,$tmpid,'$rtmp');\n";
      }
      #print STDERR "$host NS: $sqlstr\n";
      die("cannot insert entries for host in ns_entries!") 
	if (db_exec($sqlstr)<0);
      $j++;
    }

    if (@{$rec->{TXT}} > 0) {
      $sqlstr='';
      foreach $rtmp (@{$rec->{TXT}}) {
	$sqlstr .= "INSERT INTO txt_entries (type,ref,txt) " . 
                   " VALUES(2,$tmpid,'$rtmp');\n";
      }
      die("cannot insert entries for host in txt_entries!") 
	if (db_exec($sqlstr)<0);
      $j++;
    }

    if ($j>100) {
      print STDERR "å";
      $j=0;
    }
  }  
  #die("Cannot commit MX & WKS tempate pointer updates!") if (db_commit() < 0);
  print "\n";

    
  print "Updating glue records...\n";
  #db_begin();
  for $host (@gluelist) {
    $res = db_exec("UPDATE hosts SET type=6 WHERE zone=$zoneid " .
		   "AND domain='$host';");
    warn("Cannot update host record for '$host'!") if ($res < 0);
  }
  #warn("Cannot update glue record(s)!") if (db_commit() < 0);

} # for($i... zone loop


# make loopback domains global
#if (@loopbacks_list > 0) {
#  print "Making loopbacks global...\n";
#  foreach $id (@loopbacks_list) {
#    #print "id=$id\n";
#    $sqlstr="UPDATE zones SET server=0 WHERE id=$id;";
#    $res = db_exec($sqlstr);
#    die("Cannot update zone record (id=$id)!") if ($res < 0);
#  }
#}


$res = db_exec("UPDATE servers SET hostmaster='$hostmaster'," .
	       "hostname='$primaryservername' WHERE id=$serverid;");
die("Cannot update server record!") if ($res < 0);

die("Cannot commit import to database!") if (db_commit() < 0);

print STDERR "Vacuuming...";
db_vacuum();
print STDERR "\n";
exit;


##########################################################################
# subroutines

# find which IPs have multiple domainnames
sub find_multi_ips($) {
  my($serverid) = @_;
  my(@sqlstr,$res,$c,$i,$ip,$count);

  undef %mips;

  $sqlstr = "SELECT rr_a.ip,COUNT(*) FROM rr_a,hosts,zones " .
	    "WHERE rr_a.host=hosts.id AND hosts.zone=zones.id " .
	    "  AND zones.server=$serverid " .
	    "GROUP BY rr_a.ip " .
	    "HAVING COUNT(*) >1;";
  $res = db_exec($sqlstr);

  if ($res > 0) {
    $c=$res;
    for($i=0;$i < $c; $i+=1) {
      $ip=db_getvalue($i,0);
      $count=db_getvalue($i,1);
      #print "\nIP with multiple domainnames $ip count=$count ";
      $mips{$ip}=$count;
    }
  }

}





